// Programa de exemplo do simulador de Máquina Norma

// Comentários de linha começam com '//'

// Registradores são strings começando com 
// letras maiúsculas. Ex: X,Y,A,B,Abc,A1,B_2 ...

// Rótulos são strings começando com 
// números ou minúsculas. Ex: 1, 1a, ab1, a_2 ...

// Comandos disponíveis 
// inc R              (R:=R+1)
// dec R              (R:=R-1)
// add R n            (R:=R+n)
// sub R n            (R:=R-n)
// foo(R1,R2,...,Rn)  chamada de subrotina de operação

// Testes disponíveis 
// zero R             (R=0)
// cmp  R n           (R=n)
// foo(R1,R2,...,Rn)  chamada de subrotina de teste

// Definição de subrotina de operação:
// Rótulo inicial = rótulo da primeira instrução       (1 por convenção)
// Rótulo final   = referência a rótulo que não ocorre (0 por convenção)
// Parâmetros     = nomes de registradores, separados por vírgula


// A:=0 
operation zerar(A){ 
    1: if zero A then goto 0 else goto 2 
    2: do dec A goto 1 
} 

// A:=A+B usando C (soma conservative) 
operation soma(A,B,C){
    1: if zero B then goto 5 else goto 2 
    2: do dec B goto 3 
    3: do inc A goto 4 
    4: do inc C goto 1 
    5: if zero C then goto 0 else goto 6
    6: do dec C goto 7 
    7: do inc B goto 5 
} 
// A:=B usando C (atribuição conservativa) 
operation atribui(A,B,C){ 
    1: do zerar(A) goto 2 
    2: do soma(A,B,C) goto 0 
}

// A:=A-B usando C (subtração conservativa) 
operation subtrai(A,B,C){ 
    1: do atribui(C,B) goto 2 
    2: if zero C then goto 0 else goto 3 
    3: do dec C goto 4 
    4: do inc B goto 5 
    5: do dec A goto 2 
}

// testa se A = B usando COPY_R1, COPY_R2, AUX 
test igual(R1, R2, COPY_R1, COPY_R2, AUX) { 
    1: do atribui(COPY_R1, R1, AUX) goto 2 
    2: do atribui(COPY_R2, R2, AUX) goto 3 
    3: if zero COPY_R1 then goto 4 else goto 5 
    4: if zero COPY_R2 then goto true else goto 8 
    5: if zero COPY_R2 then goto 9 else goto 6 
    6: do dec COPY_R1 goto 7 
    7: do dec COPY_R2 goto 3 
    8: do zerar (COPY_R2) goto false 
    9: do zerar(COPY_R1) goto false
}

// calcula o valor absoluto do inteiro codificado pelo 
// valor armazenudo em R e armazena o resultado em ABS_R 
// e calcula também a paridade do valor armazenado em R 
// e armazena em P_R 
operation calculaflagemodulo(R, ABS_R, P_R, COPY_R, AUX) { 
    1: do atribui (COPY_R, R, AUX) goto 2 
    2: if zero COPY_R then goto 0 else goto 3 
    3: do dec COPY_R goto 4 
    4: if zero COPY_R then goto 5 else goto 7 
    5: do inc ABS_R goto 6 
    6: do inc P_R goto 0 
    7: do dec COPY_R goto 8 
    8: do inc ABS_R goto 2
}

operation somainteiros(A, B, R, ABS_A, ABS_B, P_A, P_B, AUX_A, AUX_B, AUX) { 
    1: do calculaflagemodulo(A, ABS_A, P_A, AUX_A, AUX) goto 2 
    2: do calculaflagemodulo(B, ABS_B, P_B, AUX_B, AUX) goto 3 
    3: if igual(P_A, P_B, AUX_A, AUX_B, AUX) then goto 6 else goto 4 
    4: if igual(ABS_A, ABS_B, AUX_A, AUX_B, AUX) then goto 0 else goto 10 
    5: if igual(P_A, P_B, AUX_A, AUX_B, AUX) then goto 5 else goto 0
    6: do soma (R, A, AUX_A) goto 7 
    7: do soma (R, B, AUX_B) goto 8 
    8: if zero P_A then goto 0 else goto 9 
    9: do inc R goto 0 
    10: do soma(R, A, AUX_A) goto 11 
    11: do subtrai(R, B, AUX_B) goto 12 
    12: if zero P_B then goto 0 else goto 13 
    13: do dec R goto 0
}

// A>=B usando C,D,E (retorna true se A>=B e false caso contrário) 
test maior_ou_igual(A,B,C,D,E){ 
    1: do atribui(C,A,E) goto 2 
    2: do atribui(D,B,E) goto 3 
    3: if zero D then goto 4 else goto 5
    4: do zerar(C) goto true 
    5: if zero C then goto 6 else goto 7 
    6: do zerar(D) goto false 
    7: do dec C goto 8 
    8: do dec D goto 3
}

operation div_mod(A,B,Q,R,COPY_A, COPY_B, AUX1, AUX2, AUX3) {
    1: do atribui(COPY_A,A,AUX1) goto 2 
    2: do atribui(COPY_B,B,AUX1) goto 3 
    3: if maior_ou_igual(COPY_A, COPY_B, AUX1, AUX2 , AUX3) then goto 4 else goto 6 
    4: do subtrai(COPY_A, COPY_B, AUX1) goto 5 
    5: do inc Q goto 3 
    6: do atribui(R, COPY_A) goto 7 
    7: do zerar(COPY_B) goto 0
}

operation inteiro_mais_prox(A,B,Q,R, AUX1, AUX2, AUX3, AUX4, AUX5) {
    1: do div_mod(A,B,Q,R, AUX1, AUX2, AUX3, AUX4, AUX5) goto 2 
    2: do atribui(AUX1, R, AUX2) goto 3 
    3: do soma(R, AUX1) goto 4 
    4: if maior_ou_igual(R,B,AUX1, AUX2 , AUX3) then goto 5 else goto 6 
    5: do inc Q goto 6 
    6: do atribui(Y,Q) goto 7 
    7: do zerar(R) goto 0
}
}

// A:=A div 2 usando C (divisão inteira por 2)
operation div2(A,C){
  1: do load(C,A) goto 2
  2: if zero C then goto 0 else goto 3
  3: do dec C goto 4
  4: if zero C then goto 0 else goto 5
  5: do dec C goto 6
  6: do inc A goto 2
}

// A divisivel_por_2 usando C (teste se multiplo de 2)
test divBy2(A,C){
  1: do load(C,A) goto 2
  2: if zero C then goto true else goto 3
  3: do dec C goto 4
  4: do inc A goto 5
  5: if zero C then goto false else goto 6
  6: do inc A goto 7
  7: do dec C goto 2
}

// A:=fst(B) usando C,D (extrai o primeiro componente do par)
operation fst(A,B,C,D){
  1: do clear(A) goto 2
  2: do load(C,B,D) goto 3
  3: if divBy2(C,D) then goto 4 else goto 6
  4: do div2(C,D) goto 5
  5: do inc A goto 3
  6: do clear(C) goto 0
}

// A:=A div 3 usando C (divisão inteira por 3)
operation div3(A,C){
  1: do load(C,A) goto 2
  2: if zero C then goto 0 else goto 3
  3: do dec C goto 4
  4: if zero C then goto 0 else goto 5
  5: do dec C goto 6
  6: if zero C then goto 0 else goto 7
  7: do dec C goto 8
  8: do inc A goto 2
}

// A divisivel_por_3 usando C (teste se múltiplo de 3)
test divBy3(A,C){
  1: do load(C,A) goto 2
  2: if zero C then goto true else goto 3
  3: do dec C goto 4
  4: do inc A goto 5
  5: if zero C then goto false else goto 6
  6: do inc A goto 7
  7: do dec C goto 8
  8: if zero C then goto false else goto 9
  9: do dec C goto 10
 10: do inc A goto 2
}

// A:=snd(B) usando C,D (extrai o segundo componente do par)
operation snd(A,B,C,D){
  1: do clear(A) goto 2
  2: do load(C,B,D) goto 3
  3: if divBy3(C,D) then goto 4 else goto 6
  4: do div3(C,D) goto 5
  5: do inc A goto 3
  6: do clear(C) goto 0
}

// Programa principal
main {
  // extrai o primeiro componente do par
  1: do fst(A,X,C,D) goto 2  
  // extrai o segundo  componente do par
  2: do snd(B,X,C,D) goto 3  
  // coloca em Y a soma dos dois componentes
  3: do soma(Y,A) goto 4      
  4: do soma(Y,B) goto 0      
} 
main {
    1: do add A 12 goto 2 
    2: do add B 4 goto 3 
    3: do inteiro_mais_prox(A,B,Q,R,AUX1, AUX2, AUX3, AUX4, AUX5) goto 0
}
main{
    1: do add A 9 goto 2 
    2: do add B 4 goto 3 
    3: do somainteiros(A, B, R, ABS_A, ABS_B, P_A, P_B, AUX_A, AUX_B, AUX) goto 4
    4: do atribui(Y, R) goto 0
}